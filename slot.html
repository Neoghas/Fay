<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Faylotto Ultimate - Frontend</title>

  <!-- Ethers.js v5 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>

  <style>
    :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa4b2;--accent:#6ee7b7}
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{margin:0;background:linear-gradient(180deg,#071021 0%,#071827 100%);color:#dbe7ef;min-height:100vh;padding:28px}
    .container{max-width:1000px;margin:0 auto}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:18px}
    h1{font-size:20px;margin:0}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:16px;border-radius:12px;margin-bottom:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .row{display:flex;gap:12px}
    .col{flex:1}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    input,select,button{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    button{cursor:pointer}
    .small{font-size:13px;color:var(--muted)}
    .inline{display:flex;gap:8px;align-items:center}
    .actions{display:flex;gap:8px;flex-wrap:wrap}
    .btn-primary{background:var(--accent);color:#042018;border:none}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
    .status{font-size:13px;color:var(--muted);margin-top:6px}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    pre{white-space:pre-wrap;background:rgba(0,0,0,0.2);padding:12px;border-radius:8px;overflow:auto;color:#cfeee1}
    footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:center}
    @media(max-width:800px){.grid{grid-template-columns:repeat(1,1fr)} .row{flex-direction:column}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Faylotto Ultimate — Frontend</h1>
      <div class="inline">
        <div id="walletAddress" class="small">Not connected</div>
        <button id="connectBtn" class="btn-ghost">Connect Wallet</button>
      </div>
    </header>

    <!-- Info Card -->
    <div class="card">
      <div class="row">
        <div class="col">
          <label>Contract</label>
          <div id="contractInfo" class="small">CONTRACT_ADDRESS (set in script)</div>
          <div class="status" id="networkStatus"></div>
        </div>
        <div class="col">
          <label>Round</label>
          <div id="currentRound" class="small">-</div>
          <div class="status">Active Teams: <span id="activeTeams">-</span></div>
        </div>
        <div class="col">
          <label>User Credits</label>
          <div class="small">ETH credit: <span id="creditETH">0</span></div>
          <div class="small">USDT credit: <span id="creditUSDT">0</span></div>
          <div class="small">SHIB credit: <span id="creditSHIB">0</span></div>
          <div class="small">Free SHIB: <span id="freeSHIB">0</span></div>
        </div>
      </div>
    </div>

    <!-- Register -->
    <div class="card">
      <h3 style="margin-top:0">Register / Referral</h3>
      <div class="grid">
        <div>
          <label>Nickname</label>
          <input id="nickname" placeholder="min 3 chars" />
        </div>
        <div>
          <label>Referrer Nickname (optional)</label>
          <input id="referrer" placeholder="nickname referrer" />
        </div>
        <div style="display:flex;flex-direction:column;gap:8px;justify-content:flex-end">
          <button id="registerBtn" class="btn-primary">Register</button>
          <div id="registerStatus" class="small"></div>
        </div>
      </div>
    </div>

    <!-- Betting -->
    <div class="card">
      <h3 style="margin-top:0">Place Bet</h3>
      <div class="row">
        <div class="col">
          <label>Currency</label>
          <select id="currencySelect">
            <option value="ETH">ETH</option>
            <option value="USDT">USDT</option>
            <option value="SHIB">SHIB</option>
          </select>
        </div>
        <div class="col">
          <label>Animal (0 - 5)</label>
          <select id="animalSelect">
            <option value="0">0</option>
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
          </select>
        </div>
        <div class="col">
          <label>Free Bet (SHIB only)</label>
          <select id="freeBetSelect">
            <option value="false">No</option>
            <option value="true">Yes (SHIB free)</option>
          </select>
        </div>
      </div>

      <div style="margin-top:12px" class="actions">
        <button id="approveBtn" class="btn-ghost">Approve Token (USDT/SHIB)</button>
        <button id="betBtn" class="btn-primary">Place Bet</button>
        <button id="executeBtn" class="btn-ghost">Execute Draw</button>
      </div>
      <div id="betStatus" class="status"></div>
    </div>

    <!-- Actions -->
    <div class="card">
      <h3 style="margin-top:0">Actions</h3>
      <div class="row">
        <div class="col">
          <label>Claim Referral Bonus (Free SHIB)</label>
          <button id="claimBonusBtn" class="btn-primary">Claim Bonus</button>
          <div id="claimStatus" class="small"></div>
        </div>
        <div class="col">
          <label>Withdraw Internal Credit</label>
          <select id="withdrawCurrency">
            <option value="ETH">ETH</option>
            <option value="USDT">USDT</option>
            <option value="SHIB">SHIB</option>
          </select>
          <input id="withdrawAmount" placeholder="amount (wei for tokens/ETH as raw)" />
          <button id="withdrawBtn" class="btn-primary">Withdraw</button>
          <div id="withdrawStatus" class="small"></div>
        </div>
        <div class="col">
          <label>Quick Info</label>
          <div class="small">Gas & tx will show in MetaMask</div>
          <div class="small">Jika kontrak butuh approve untuk token, tekan Approve</div>
        </div>
      </div>
    </div>

    <!-- Round history -->
    <div class="card">
      <h3 style="margin-top:0">Round History (recent)</h3>
      <div id="historyArea"><pre id="historyText">-</pre></div>
    </div>

    <footer>Frontend sederhana untuk kontrak FaylottoUltimate — ubah constants di bawah sesuai kebutuhan</footer>
  </div>

  <script>
  (async () => {
    // ----- CONFIG: Ganti sesuai kontrak Anda -----
    const CONTRACT_ADDRESS = "0xCONTRACT_ADDRESS_REPLACE_ME"; // <-- ganti
    const USDT_ADDRESS = "0xUSDT_ADDRESS_REPLACE_ME"; // <-- ganti
    const SHIB_ADDRESS = "0xSHIB_ADDRESS_REPLACE_ME"; // <-- ganti

    // ABI minimal (sesuaikan jika Anda menambahkan fungsi / event)
    const CONTRACT_ABI = [
      // owner / info
      "function currentRoundId() view returns (uint256)",
      "function getRoundResult(uint256) view returns (tuple(uint8[3] reels,string outcome,uint256 timestamp,address winner))",
      "function getActiveTeamCount() view returns (uint256)",
      "function userCredits(address, uint8) view returns (uint256)",
      "function freeShibCredits(address) view returns (uint256)",
      // user actions
      "function register(string,string) external",
      "function claimReferralBonus() external",
      "function betETH(uint8) payable external",
      "function betToken(uint8, uint8, bool) external",
      "function executeDraw() external",
      "function withdrawCredit(uint8,uint256) external",
      // events (optional)
      "event NewBet(address indexed player, uint8 animalChoice, uint256 timestamp)",
      "event BattleResult(uint8[3] reels, string outcome, uint256 roundId)",
      "event WinDistributed(address indexed winner, uint256 amount, uint8 curr, bool isRealTransfer)"
    ];
    // --------------------------------------------

    const provider = new ethers.providers.Web3Provider(window.ethereum, "any");
    let signer = null;
    let contract = null;
    let userAddress = null;

    // DOM refs
    const connectBtn = document.getElementById("connectBtn");
    const walletAddress = document.getElementById("walletAddress");
    const networkStatus = document.getElementById("networkStatus");
    const contractInfo = document.getElementById("contractInfo");
    contractInfo.innerText = CONTRACT_ADDRESS;

    const currentRoundEl = document.getElementById("currentRound");
    const activeTeamsEl = document.getElementById("activeTeams");
    const creditETH = document.getElementById("creditETH");
    const creditUSDT = document.getElementById("creditUSDT");
    const creditSHIB = document.getElementById("creditSHIB");
    const freeSHIB = document.getElementById("freeSHIB");

    const registerBtn = document.getElementById("registerBtn");
    const nicknameInput = document.getElementById("nickname");
    const refInput = document.getElementById("referrer");
    const registerStatus = document.getElementById("registerStatus");

    const approveBtn = document.getElementById("approveBtn");
    const betBtn = document.getElementById("betBtn");
    const executeBtn = document.getElementById("executeBtn");
    const betStatus = document.getElementById("betStatus");
    const historyText = document.getElementById("historyText");

    const claimBonusBtn = document.getElementById("claimBonusBtn");
    const claimStatus = document.getElementById("claimStatus");

    const withdrawBtn = document.getElementById("withdrawBtn");
    const withdrawStatus = document.getElementById("withdrawStatus");

    // init
    async function initContract(s) {
      signer = s;
      contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
    }

    // connect wallet
    connectBtn.addEventListener("click", async () => {
      try {
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        walletAddress.innerText = `${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;
        connectBtn.innerText = "Connected";
        await initContract(signer);
        pollAll();
      } catch (err) {
        console.error(err);
        walletAddress.innerText = "Connection failed";
      }
    });

    // utility: show error
    function showStatus(el, msg, isErr = false) {
      el.innerText = msg;
      el.style.color = isErr ? "#ff8a8a" : "";
      setTimeout(()=>{ if(el.innerText === msg) el.innerText = ""; }, 7000);
    }

    // register
    registerBtn.addEventListener("click", async () => {
      try {
        const nick = nicknameInput.value.trim();
        const ref = refInput.value.trim();
        if (!nick || nick.length < 3) return showStatus(registerStatus, "Nickname min 3 chars", true);
        const tx = await contract.register(nick, ref);
        showStatus(registerStatus, "Waiting tx...");
        await tx.wait();
        showStatus(registerStatus, "Registered ✔");
        await pollCredits();
      } catch (err) {
        console.error(err);
        showStatus(registerStatus, "Register failed: " + (err?.message || err), true);
      }
    });

    // approve token (max)
    approveBtn.addEventListener("click", async () => {
      try {
        const currency = document.getElementById("currencySelect").value;
        if (currency === "ETH") return showStatus(betStatus, "ETH tidak perlu approve");
        const tokenAddr = currency === "USDT" ? USDT_ADDRESS : SHIB_ADDRESS;
        const tokenAbi = ["function approve(address spender, uint256 amount) public returns (bool)"];
        const token = new ethers.Contract(tokenAddr, tokenAbi, signer);
        const max = ethers.constants.MaxUint256;
        const tx = await token.approve(CONTRACT_ADDRESS, max);
        showStatus(betStatus, "Approve pending...");
        await tx.wait();
        showStatus(betStatus, "Approve ok");
      } catch (err) {
        console.error(err);
        showStatus(betStatus, "Approve failed: " + (err?.message || err), true);
      }
    });

    // place bet
    betBtn.addEventListener("click", async () => {
      try {
        if (!contract) return showStatus(betStatus, "Connect first", true);
        const currency = document.getElementById("currencySelect").value;
        const animal = parseInt(document.getElementById("animalSelect").value);
        const isFree = document.getElementById("freeBetSelect").value === "true";

        if (currency === "ETH") {
          // COST_ETH = 0.0005 ether
          const cost = ethers.utils.parseEther("0.0005");
          const tx = await contract.betETH(animal, { value: cost });
          showStatus(betStatus, "Bet ETH tx pending...");
          await tx.wait();
          showStatus(betStatus, "Bet placed (ETH) ✔");
        } else if (currency === "USDT") {
          if (isFree) return showStatus(betStatus, "USDT tidak mendukung free bet", true);
          // COST_USDT = 10 * 10**6  (10 USDT with 6 decimals)
          const cost = ethers.BigNumber.from("10000000"); // 10*10^6
          const currEnum = 1; // Currency.USDT -> 1 (as enum)
          const tx = await contract.betToken(animal, currEnum, false);
          showStatus(betStatus, "Bet USDT tx pending...");
          await tx.wait();
          showStatus(betStatus, "Bet placed (USDT) ✔");
        } else {
          // SHIB
          const currEnum = 2; // Currency.SHIB -> 2
          if (isFree) {
            const tx = await contract.betToken(animal, currEnum, true);
            showStatus(betStatus, "Bet SHIB (FREE) tx pending...");
            await tx.wait();
            showStatus(betStatus, "Free SHIB bet placed ✔");
          } else {
            // COST_SHIB_MAIN = 110000 * 10**18
            const tx = await contract.betToken(animal, currEnum, false);
            showStatus(betStatus, "Bet SHIB (MAIN) tx pending...");
            await tx.wait();
            showStatus(betStatus, "Bet placed (SHIB) ✔");
          }
        }

        await pollAll();
      } catch (err) {
        console.error(err);
        showStatus(betStatus, "Bet failed: " + (err?.data?.message || err?.message || err), true);
      }
    });

    // execute draw (anyone)
    executeBtn.addEventListener("click", async () => {
      try {
        if (!contract) return showStatus(betStatus, "Connect first", true);
        const tx = await contract.executeDraw();
        showStatus(betStatus, "Executing draw...");
        await tx.wait();
        showStatus(betStatus, "Draw executed ✔");
        await pollAll();
      } catch (err) {
        console.error(err);
        showStatus(betStatus, "Execute failed: " + (err?.message || err), true);
      }
    });

    // claim referral
    claimBonusBtn.addEventListener("click", async () => {
      try {
        if (!contract) return showStatus(claimStatus, "Connect first", true);
        const tx = await contract.claimReferralBonus();
        showStatus(claimStatus, "Claim tx pending...");
        await tx.wait();
        showStatus(claimStatus, "Claimed ✔");
        await pollAll();
      } catch (err) {
        console.error(err);
        showStatus(claimStatus, "Claim failed: " + (err?.message || err), true);
      }
    });

    // withdraw internal credit
    withdrawBtn.addEventListener("click", async () => {
      try {
        if (!contract) return showStatus(withdrawStatus, "Connect first", true);
        const curr = document.getElementById("withdrawCurrency").value;
        const amountRaw = document.getElementById("withdrawAmount").value.trim();
        if (!amountRaw) return showStatus(withdrawStatus, "Masukkan jumlah", true);

        const enumMap = { "ETH": 0, "USDT": 1, "SHIB": 2 };
        const currEnum = enumMap[curr];
        // NOTE: the contract expects raw uint256 amounts (wei for ETH, decimals for tokens)
        const amount = ethers.BigNumber.from(amountRaw);
        const tx = await contract.withdrawCredit(currEnum, amount);
        showStatus(withdrawStatus, "Withdraw tx pending...");
        await tx.wait();
        showStatus(withdrawStatus, "Withdraw done ✔");
        await pollAll();
      } catch (err) {
        console.error(err);
        showStatus(withdrawStatus, "Withdraw failed: " + (err?.message || err), true);
      }
    });

    // POLLING: fetch credits / round / history
    async function pollAll(){
      try {
        if (!contract) return;
        const roundIdBN = await contract.currentRoundId();
        const roundId = roundIdBN.toNumber();
        currentRoundEl.innerText = String(roundId);
        const activeCount = await contract.getActiveTeamCount();
        activeTeamsEl.innerText = String(activeCount);

        // credits (contract uses enum Currency: ETH=0,USDT=1,SHIB=2)
        const ethCredit = await contract.userCredits(userAddress, 0);
        const usdtCredit = await contract.userCredits(userAddress, 1);
        const shibCredit = await contract.userCredits(userAddress, 2);
        const freeShib = await contract.freeShibCredits(userAddress);

        creditETH.innerText = ethCredit.toString();
        creditUSDT.innerText = usdtCredit.toString();
        creditSHIB.innerText = shibCredit.toString();
        freeSHIB.innerText = freeShib.toString();

        // show last 5 rounds
        const latest = Math.max(roundId - 1, 1);
        let out = [];
        for(let r = latest; r >= Math.max(1, latest - 4); r--) {
          try {
            const res = await contract.getRoundResult(r);
            // res: { reels: [u8,u8,u8], outcome, timestamp, winner }
            out.push(`#${r} — ${res.outcome} — reels: ${res.reels[0]},${res.reels[1]},${res.reels[2]} — winner: ${res.winner} — ${new Date(res.timestamp*1000).toLocaleString()}`);
          } catch(e) {
            // ignore
          }
        }
        historyText.innerText = out.join("\n") || "No rounds yet";
      } catch (err) {
        console.error(err);
      }
    }

    // automatically poll every 12s if connected
    setInterval(()=>{ if (contract && userAddress) pollAll(); }, 12000);

    // detect network / account changes
    if (window.ethereum) {
      window.ethereum.on("accountsChanged", async (accounts) => {
        if (accounts.length === 0) {
          walletAddress.innerText = "Not connected";
        } else {
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          walletAddress.innerText = `${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;
          await initContract(signer);
          pollAll();
        }
      });
      window.ethereum.on("chainChanged", (chainId) => {
        networkStatus.innerText = "Chain changed: " + chainId;
      });
    } else {
      networkStatus.innerText = "No Web3 provider found. Install MetaMask.";
    }

    // initial small attempt to get provider network
    try {
      const net = await provider.getNetwork();
      networkStatus.innerText = `Network: ${net.name || net.chainId}`;
    } catch(e) {}

    // NOTES for user (console)
    console.log("Faylotto frontend ready. Make sure you replaced CONTRACT_ADDRESS, USDT_ADDRESS, SHIB_ADDRESS in the script.");
  })();
  </script>
</body>
</html>
